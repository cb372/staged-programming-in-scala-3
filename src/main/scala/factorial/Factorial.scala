package factorial

import scala.quoted.*

/*
 * Example of using a macro to calculate a factorial,
 * unrolling the recursive call during the macro expansion
 * to avoid recursion at runtime.
 */

def factorialMacro(n: Expr[Int])(using Quotes): Expr[Int] =
  val expr = n.valueOrError match {
    case 1 => '{1}
    case x => '{ ${Expr(x)} * ${factorialMacro(Expr(x - 1))}}
  }

  // This will be printed at compile time (you can check with `sbt compile`)
  println("Code generated by factorialMacro: " + expr.show)
  expr

inline def factorial(n: Int): Int = ${ factorialMacro('n) }

/*
 * The same example, this time using staged programming.
 *
 * Note how `factorialStaged` takes a plain value of type `Int`
 * and returns a program fragment of type `Expr[Int].
 *
 * This is in contrast to the `factorialMacro`, which takes
 * a program fragment as input and returns a program fragment.
 */

import scala.quoted.staging.*

def factorialStaged(n: Int)(using Quotes): Expr[Int] =
  val expr = n match {
    case 1 => '{1}
    case x => '{${Expr(x)} * ${factorialStaged(x - 1)}}
  }

  // This will be printed at runtime (you can check with `sbt compile; sbt run`)
  println("Code generated by factorialStaged: " + expr.show)
  expr

def runFactorialStaged(n: Int): Int =
  given Compiler = Compiler.make(getClass.getClassLoader)

  run {
    val code = factorialStaged(n)
    println("Staged code: " + code.show)
    code
  }
